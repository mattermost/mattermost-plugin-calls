// Code generated by mockery v2.38.0. DO NOT EDIT.

package mlog

import (
	log "log"

	logr "github.com/mattermost/logr/v2"
	mlog "github.com/mattermost/mattermost/server/public/shared/mlog"

	mock "github.com/stretchr/testify/mock"
)

// MockLoggerIFace is an autogenerated mock type for the LoggerIFace type
type MockLoggerIFace struct {
	mock.Mock
}

type MockLoggerIFace_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLoggerIFace) EXPECT() *MockLoggerIFace_Expecter {
	return &MockLoggerIFace_Expecter{mock: &_m.Mock}
}

// Critical provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Critical(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Critical_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Critical'
type MockLoggerIFace_Critical_Call struct {
	*mock.Call
}

// Critical is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Critical(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Critical_Call {
	return &MockLoggerIFace_Critical_Call{Call: _e.mock.On("Critical",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Critical_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Critical_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Critical_Call) Return() *MockLoggerIFace_Critical_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Critical_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Critical_Call {
	_c.Call.Return(run)
	return _c
}

// Debug provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Debug(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Debug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debug'
type MockLoggerIFace_Debug_Call struct {
	*mock.Call
}

// Debug is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Debug(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Debug_Call {
	return &MockLoggerIFace_Debug_Call{Call: _e.mock.On("Debug",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Debug_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Debug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Debug_Call) Return() *MockLoggerIFace_Debug_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Debug_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Debug_Call {
	_c.Call.Return(run)
	return _c
}

// Error provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Error(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type MockLoggerIFace_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Error(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Error_Call {
	return &MockLoggerIFace_Error_Call{Call: _e.mock.On("Error",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Error_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Error_Call) Return() *MockLoggerIFace_Error_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Error_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Error_Call {
	_c.Call.Return(run)
	return _c
}

// Fatal provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Fatal(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Fatal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fatal'
type MockLoggerIFace_Fatal_Call struct {
	*mock.Call
}

// Fatal is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Fatal(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Fatal_Call {
	return &MockLoggerIFace_Fatal_Call{Call: _e.mock.On("Fatal",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Fatal_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Fatal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Fatal_Call) Return() *MockLoggerIFace_Fatal_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Fatal_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Fatal_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with given fields:
func (_m *MockLoggerIFace) Flush() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLoggerIFace_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MockLoggerIFace_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *MockLoggerIFace_Expecter) Flush() *MockLoggerIFace_Flush_Call {
	return &MockLoggerIFace_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *MockLoggerIFace_Flush_Call) Run(run func()) *MockLoggerIFace_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLoggerIFace_Flush_Call) Return(_a0 error) *MockLoggerIFace_Flush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLoggerIFace_Flush_Call) RunAndReturn(run func() error) *MockLoggerIFace_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Info(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockLoggerIFace_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Info(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Info_Call {
	return &MockLoggerIFace_Info_Call{Call: _e.mock.On("Info",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Info_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Info_Call) Return() *MockLoggerIFace_Info_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Info_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Info_Call {
	_c.Call.Return(run)
	return _c
}

// IsLevelEnabled provides a mock function with given fields: _a0
func (_m *MockLoggerIFace) IsLevelEnabled(_a0 logr.Level) bool {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for IsLevelEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(logr.Level) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockLoggerIFace_IsLevelEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsLevelEnabled'
type MockLoggerIFace_IsLevelEnabled_Call struct {
	*mock.Call
}

// IsLevelEnabled is a helper method to define mock.On call
//   - _a0 logr.Level
func (_e *MockLoggerIFace_Expecter) IsLevelEnabled(_a0 interface{}) *MockLoggerIFace_IsLevelEnabled_Call {
	return &MockLoggerIFace_IsLevelEnabled_Call{Call: _e.mock.On("IsLevelEnabled", _a0)}
}

func (_c *MockLoggerIFace_IsLevelEnabled_Call) Run(run func(_a0 logr.Level)) *MockLoggerIFace_IsLevelEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(logr.Level))
	})
	return _c
}

func (_c *MockLoggerIFace_IsLevelEnabled_Call) Return(_a0 bool) *MockLoggerIFace_IsLevelEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLoggerIFace_IsLevelEnabled_Call) RunAndReturn(run func(logr.Level) bool) *MockLoggerIFace_IsLevelEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// Log provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockLoggerIFace) Log(_a0 logr.Level, _a1 string, _a2 ...logr.Field) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Log_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Log'
type MockLoggerIFace_Log_Call struct {
	*mock.Call
}

// Log is a helper method to define mock.On call
//   - _a0 logr.Level
//   - _a1 string
//   - _a2 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Log(_a0 interface{}, _a1 interface{}, _a2 ...interface{}) *MockLoggerIFace_Log_Call {
	return &MockLoggerIFace_Log_Call{Call: _e.mock.On("Log",
		append([]interface{}{_a0, _a1}, _a2...)...)}
}

func (_c *MockLoggerIFace_Log_Call) Run(run func(_a0 logr.Level, _a1 string, _a2 ...logr.Field)) *MockLoggerIFace_Log_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(logr.Level), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Log_Call) Return() *MockLoggerIFace_Log_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Log_Call) RunAndReturn(run func(logr.Level, string, ...logr.Field)) *MockLoggerIFace_Log_Call {
	_c.Call.Return(run)
	return _c
}

// LogM provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockLoggerIFace) LogM(_a0 []logr.Level, _a1 string, _a2 ...logr.Field) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_LogM_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogM'
type MockLoggerIFace_LogM_Call struct {
	*mock.Call
}

// LogM is a helper method to define mock.On call
//   - _a0 []logr.Level
//   - _a1 string
//   - _a2 ...logr.Field
func (_e *MockLoggerIFace_Expecter) LogM(_a0 interface{}, _a1 interface{}, _a2 ...interface{}) *MockLoggerIFace_LogM_Call {
	return &MockLoggerIFace_LogM_Call{Call: _e.mock.On("LogM",
		append([]interface{}{_a0, _a1}, _a2...)...)}
}

func (_c *MockLoggerIFace_LogM_Call) Run(run func(_a0 []logr.Level, _a1 string, _a2 ...logr.Field)) *MockLoggerIFace_LogM_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].([]logr.Level), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_LogM_Call) Return() *MockLoggerIFace_LogM_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_LogM_Call) RunAndReturn(run func([]logr.Level, string, ...logr.Field)) *MockLoggerIFace_LogM_Call {
	_c.Call.Return(run)
	return _c
}

// StdLogger provides a mock function with given fields: level
func (_m *MockLoggerIFace) StdLogger(level logr.Level) *log.Logger {
	ret := _m.Called(level)

	if len(ret) == 0 {
		panic("no return value specified for StdLogger")
	}

	var r0 *log.Logger
	if rf, ok := ret.Get(0).(func(logr.Level) *log.Logger); ok {
		r0 = rf(level)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*log.Logger)
		}
	}

	return r0
}

// MockLoggerIFace_StdLogger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StdLogger'
type MockLoggerIFace_StdLogger_Call struct {
	*mock.Call
}

// StdLogger is a helper method to define mock.On call
//   - level logr.Level
func (_e *MockLoggerIFace_Expecter) StdLogger(level interface{}) *MockLoggerIFace_StdLogger_Call {
	return &MockLoggerIFace_StdLogger_Call{Call: _e.mock.On("StdLogger", level)}
}

func (_c *MockLoggerIFace_StdLogger_Call) Run(run func(level logr.Level)) *MockLoggerIFace_StdLogger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(logr.Level))
	})
	return _c
}

func (_c *MockLoggerIFace_StdLogger_Call) Return(_a0 *log.Logger) *MockLoggerIFace_StdLogger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLoggerIFace_StdLogger_Call) RunAndReturn(run func(logr.Level) *log.Logger) *MockLoggerIFace_StdLogger_Call {
	_c.Call.Return(run)
	return _c
}

// Sugar provides a mock function with given fields: fields
func (_m *MockLoggerIFace) Sugar(fields ...logr.Field) logr.Sugar {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Sugar")
	}

	var r0 logr.Sugar
	if rf, ok := ret.Get(0).(func(...logr.Field) logr.Sugar); ok {
		r0 = rf(fields...)
	} else {
		r0 = ret.Get(0).(logr.Sugar)
	}

	return r0
}

// MockLoggerIFace_Sugar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sugar'
type MockLoggerIFace_Sugar_Call struct {
	*mock.Call
}

// Sugar is a helper method to define mock.On call
//   - fields ...logr.Field
func (_e *MockLoggerIFace_Expecter) Sugar(fields ...interface{}) *MockLoggerIFace_Sugar_Call {
	return &MockLoggerIFace_Sugar_Call{Call: _e.mock.On("Sugar",
		append([]interface{}{}, fields...)...)}
}

func (_c *MockLoggerIFace_Sugar_Call) Run(run func(fields ...logr.Field)) *MockLoggerIFace_Sugar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Sugar_Call) Return(_a0 logr.Sugar) *MockLoggerIFace_Sugar_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLoggerIFace_Sugar_Call) RunAndReturn(run func(...logr.Field) logr.Sugar) *MockLoggerIFace_Sugar_Call {
	_c.Call.Return(run)
	return _c
}

// Trace provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Trace(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Trace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Trace'
type MockLoggerIFace_Trace_Call struct {
	*mock.Call
}

// Trace is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Trace(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Trace_Call {
	return &MockLoggerIFace_Trace_Call{Call: _e.mock.On("Trace",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Trace_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Trace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Trace_Call) Return() *MockLoggerIFace_Trace_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Trace_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Trace_Call {
	_c.Call.Return(run)
	return _c
}

// Warn provides a mock function with given fields: _a0, _a1
func (_m *MockLoggerIFace) Warn(_a0 string, _a1 ...logr.Field) {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// MockLoggerIFace_Warn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warn'
type MockLoggerIFace_Warn_Call struct {
	*mock.Call
}

// Warn is a helper method to define mock.On call
//   - _a0 string
//   - _a1 ...logr.Field
func (_e *MockLoggerIFace_Expecter) Warn(_a0 interface{}, _a1 ...interface{}) *MockLoggerIFace_Warn_Call {
	return &MockLoggerIFace_Warn_Call{Call: _e.mock.On("Warn",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *MockLoggerIFace_Warn_Call) Run(run func(_a0 string, _a1 ...logr.Field)) *MockLoggerIFace_Warn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_Warn_Call) Return() *MockLoggerIFace_Warn_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLoggerIFace_Warn_Call) RunAndReturn(run func(string, ...logr.Field)) *MockLoggerIFace_Warn_Call {
	_c.Call.Return(run)
	return _c
}

// With provides a mock function with given fields: fields
func (_m *MockLoggerIFace) With(fields ...logr.Field) *mlog.Logger {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for With")
	}

	var r0 *mlog.Logger
	if rf, ok := ret.Get(0).(func(...logr.Field) *mlog.Logger); ok {
		r0 = rf(fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mlog.Logger)
		}
	}

	return r0
}

// MockLoggerIFace_With_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'With'
type MockLoggerIFace_With_Call struct {
	*mock.Call
}

// With is a helper method to define mock.On call
//   - fields ...logr.Field
func (_e *MockLoggerIFace_Expecter) With(fields ...interface{}) *MockLoggerIFace_With_Call {
	return &MockLoggerIFace_With_Call{Call: _e.mock.On("With",
		append([]interface{}{}, fields...)...)}
}

func (_c *MockLoggerIFace_With_Call) Run(run func(fields ...logr.Field)) *MockLoggerIFace_With_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]logr.Field, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(logr.Field)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockLoggerIFace_With_Call) Return(_a0 *mlog.Logger) *MockLoggerIFace_With_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLoggerIFace_With_Call) RunAndReturn(run func(...logr.Field) *mlog.Logger) *MockLoggerIFace_With_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLoggerIFace creates a new instance of MockLoggerIFace. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLoggerIFace(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLoggerIFace {
	mock := &MockLoggerIFace{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
